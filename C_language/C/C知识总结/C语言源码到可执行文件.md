## C语言源码 ->	可执行文件

> readme

```
gcc
--help 
--version
-c         编译、汇编,不链接   
-S         编译,不汇编、链接	
-E         预处理,不编译、汇编、链接
-o <file>  将输出放入到一个文件file

as 汇编器(assembler)
as    .s   -o   .o    汇编文件-->目标文件

ld 链接器(linker)
ld    .o   -o  hello  目标文件-->可执行文件

```


### 一、预处理
> 预编译过程不会检查程序是否符合C语言语法;  但是会检查条件预处理指示的语法; 

1.宏定义处理   
2.文件包含处理       
3.条件预处理指示处理
  
>  - #if 
> - #else
> - #elif
> - #endif 
> - #ifndef
> - #define  
> - #undef

1、把用 \ 续行的多行字符拼接成一行 yes
> \ 后面紧跟换行,不能有空格    
> 中间会出现一个空格
    
2、把注释替换成一个空格。yes  
3、预处理 #include  头文件 ,  把对应的头文件包含进来,并对其进行预处理    
4、宏定义 展开,并且消除所有宏定义  yes.   
5、字符串中的转义字符替换。no   
6、相邻的 “...” “...” 连接起来。no    
7、去掉空白字符。   no
> 源码的空行减少,预处理后的空行也减少;  

8、处理条件预处理指示.     
9、加入引用的标识.

```c
# 1 "test1.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 361 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "test1.c" 2
....
```


##### 宏定义
1、变量式宏定义

```c
#define N 20
```  
 
2、函数式宏定义

```c
#define MAX(a, b)    MAX((a) > (b) ? (a) : (b))
```  
2.1函数式宏定义和函数调用的区别? 
  
- 函数式宏定义的参数没有类型,预处理只负责形式上的替换. 不做参数类型检查,使用的守候格外注意;   
- 函数式宏定义和调用函数 编译生成的指令不同, 传参指令和call指令,分配和释放栈帧、传参数、传返回值,函数调用运行效率慢点, 函数式宏定义会显著提高代码的执行效率,编译生成的目标文件会比较大.
-  使用函数式宏定义要注意括号的添加,不然替换后会因为运算符优先级造成问题.


3、函数式宏定义经常写成这样的形式.(取自内核代码include/linux/pm.h)

```c
#define device_init_wakeup(dev,val) \
        do { \
               device_can_wakeup(dev) = !!(val); \
               device_set_wakeup_enable(dev,val); \
        } while(0)
```

3.1 为什么要用 do { ... } while(0) 扩起来?

```c
#define device_init_wakeup(dev,val) \
        do { \
               device_can_wakeup(dev) = !!(val); \
               device_set_wakeup_enable(dev,val); \
        } while(0)

if(n > 0)
	device_init_wakeup(d, v);
```
如果这样使用的话, 宏展开后,第二条语句不在if条件中.

3.2 只简单使用 { ... } 语句块不可以么?

> 问题出在调用这个宏的时候末尾的 ; , 如果device_init_wakeup(d, v); 不写 ;,看起来不想一个调用,如果写了宏展开后就出现了语法错误.if 语句被;结束掉了,没法和else配对  

```c

if (20 < 10)
        { printf("aaaa%d\n", 4); printf("bbbb%d\n", 5); };

    else
        printf("2\n");
```

这个是预编译后的结果, 这个问题就浮现出来了,
如果在使用if的时候使用和 { },预编译后的代码就变成了这样.

```c

if (20 < 10) {
        { printf("aaaa%d\n", 4); printf("bbbb%d\n", 5); }; 
}
else {
        printf("2\n");
}
```
因为可以在一条语句后面写多个;号,(每个;都相当于一条语句),,所以就看不出来问题,    

代码规范


### 二、汇编程序
##### 1、最简单的汇编程序
1.汇编指示(伪操作)   

```
.section指示. 
把代码划分成若干段,程序被操作系统加载执行时,每个段被加载到不同的地址,具有不同的读、写、执行权限。 

.data指示. 
保存程序的数据,是可读可写的; 
C语言的全局变量

_start 符号
符号在汇编程序中代表一个地址, 可以用在指令中,汇编程序在汇编器的处理后,所有的符号都被替换成它所代表的地址值; 

在C语言中,我们通过变量名、函数名访问变量、调用函数, 其实是读写某个地址的内存单元;
变量名函数名都是符号,本质上代表内存地址;

_start就像C程序的main一样特殊,使整个程序的入口,链接器在链接的时候会查找目标文件中_start的地址,把它设置成整个程序的入口地址. 所以每个汇编程序都要有_start符号,
并且被.global指示声明,如果一个符号也没有用.global声明,就表示这个符号不会被连接器用到.

汇编器在处理汇编程序的时候,会计算每个每个数据对象和每条指令的地址
把下一条指令的地址作为_start这个符号的地址.

.global指示
告诉汇编器, _start符号要被连接器用到;

```
